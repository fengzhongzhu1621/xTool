"""
组件的行为
FactorialCalculateService 在完成 execute() 的执行后即认为该组件已经执行完成。但是在某些场景下，这样的行为并不能满足我们的需求，例如调用第三方系统的接口启动一个任务，并周期性的轮询该任务的状态，随后根据任务状态确认执行结果；或是调用第三方系统启动任务后等待第三方系统回调并根据回调数据确认执行结果。

为了满足上述的场景，pipeline 中的组件执行时的行为有以下几种：

单次执行：默认的执行方式，完成 execute() 的执行后即认为该组件已经执行完毕。
周期性轮询：完成 execute() 的执行后，还会周期性的执行 schedule() 方法，直至满足一定的条件为止。
单次回调：完成 execute() 的执行后，会等待外部回调，接收到回调后会执行一次 schedule() 方法。
多次回调：完成 execute() 的执行后，会等待外部回调，每次回调会执行一次 schedule() 方法。
总结起来，组件的执行方式可以用一条公式概括： execute + n * schedule。

------------------------------------------------------------------------------------------------------------------------
单次执行
这是组件默认的执行方式，在这种模式下，一旦 execute() 方法执行完成后，该组件即视为执行完成。执行结果会根据 execute() 的返回值来判断：

False：执行失败，节点会进入 FAILED 状态。流程终止
True 或 None：执行成功，节点会进入 FINISHED 状态，继续执行下一个节点

------------------------------------------------------------------------------------------------------------------------
单次回调
* schedule()执行成功，调用 finish_schedule(), 返回None，继续执行下一个节点
* schedule()执行失败，返回False，第二次执行时，会标记DBSchedule过期，不会重复执行

------------------------------------------------------------------------------------------------------------------------
多次回调
* schedule()执行成功，调用 finish_schedule(), 返回None，继续执行下一个节点；成功后再次执行，
成功后再次执行，则当前节点的进程不是休眠状态，不能执行
* schedule()执行失败，返回False， 流程终止，再次调用会判断节点的状态，不为RUNNING则停止执行
* schedule()执行异常，返回False， 流程终止，再次调用会判断节点的状态，不为RUNNING则停止执行
* schedule()需要重试，第一次执行返回True， 流程暂停；可以再次执行，直到失败或执行finish_schedule()
"""
