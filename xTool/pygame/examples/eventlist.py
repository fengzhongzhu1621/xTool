"""
鼠标控制
========

- 鼠标左键点击：切换事件抓取模式
- 鼠标右键点击：切换鼠标可见性
- 窗口可以调整大小
- 移动鼠标查看鼠标事件
- 如果启用事件抓取且鼠标不可见，显示虚拟鼠标坐标


键盘和游戏手柄控制
==================

- 按下键盘键查看按键事件
- 如果有连接的游戏手柄，可以查看手柄事件
- 按"c"键切换控制器事件生成
"""

import pygame as pg
import pygame._sdl2.controller

from xTool.pygame.font import showtext

usage = """
Mouse Controls
==============

- 1st button on mouse (left click) to toggle events 'grabed'.
- 3rd button on mouse (right click) to toggle mouse visible.
- The window can be resized.
- Mouse the mouse around to see mouse events.
- If events grabbed and mouse invisible show virtual mouse coords.


Keyboard Joystick Controls
==========================

- press keys up an down to see events.
- you can see joystick events if any are plugged in.
- press "c" to toggle events generated by controllers.
"""

img_on_off: list[pg.Surface] = []
font: pg.font.Font
last_key = None

# these are a running counter of mouse.get_rel() calls.
virtual_x = 0
virtual_y = 0


def drawstatus(win):
    """绘制状态区域 - 显示各种输入设备的状态信息"""
    global virtual_x, virtual_y
    bgcolor = 50, 50, 50  # 深灰色背景
    win.fill(bgcolor, (0, 0, 640, 120))  # 填充状态区域背景
    win.blit(font.render("Status Area", 1, (155, 155, 155), bgcolor), (2, 2))  # 区域标题

    # 鼠标焦点状态
    pos = showtext(win, font, (10, 30), "Mouse Focus", (255, 255, 255), bgcolor)
    win.blit(img_on_off[pg.mouse.get_focused()], pos)  # 显示鼠标焦点状态

    # 鼠标可见性状态
    pos = showtext(win, font, (pos[0] + 50, pos[1]), "Mouse visible", (255, 255, 255), bgcolor)
    win.blit(img_on_off[pg.mouse.get_visible()], pos)  # 显示鼠标可见性状态

    # 键盘焦点状态
    pos = showtext(win, font, (330, 30), "Keyboard Focus", (255, 255, 255), bgcolor)
    win.blit(img_on_off[pg.key.get_focused()], pos)  # 显示键盘焦点状态

    # 鼠标位置和相对移动
    pos = showtext(win, font, (10, 60), "Mouse Position(rel)", (255, 255, 255), bgcolor)
    rel = pg.mouse.get_rel()  # 获取鼠标相对移动量
    virtual_x += rel[0]  # 累计虚拟鼠标X坐标
    virtual_y += rel[1]  # 累计虚拟鼠标Y坐标

    mouse_data = tuple(list(pg.mouse.get_pos()) + list(rel))  # 组合鼠标数据
    p = "%s, %s (%s, %s)" % mouse_data  # 格式化显示字符串
    showtext(win, font, pos, p, bgcolor, (255, 255, 55))  # 显示鼠标位置信息

    # 最后按键信息
    pos = showtext(win, font, (330, 60), "Last Keypress", (255, 255, 255), bgcolor)
    if last_key:
        p = "%d, %s" % (last_key, pg.key.name(last_key))  # 按键代码和名称
    else:
        p = "无"
    showtext(win, font, pos, p, bgcolor, (255, 255, 55))  # 显示按键信息

    # 输入抓取状态
    pos = showtext(win, font, (10, 90), "Input Grabbed", (255, 255, 255), bgcolor)
    win.blit(img_on_off[pg.event.get_grab()], pos)  # 显示输入抓取状态

    # 虚拟鼠标状态（当输入抓取且鼠标不可见时）
    is_virtual_mouse = pg.event.get_grab() and not pg.mouse.get_visible()
    pos = showtext(win, font, (330, 90), "Virtual Mouse", (255, 255, 255), bgcolor)
    win.blit(img_on_off[is_virtual_mouse], pos)  # 显示虚拟鼠标状态
    if is_virtual_mouse:
        p = f"{virtual_x}, {virtual_y}"  # 虚拟鼠标坐标
        showtext(win, font, (pos[0] + 50, pos[1]), p, bgcolor, (255, 255, 55))  # 显示坐标


def drawhistory(win, history):
    img = font.render("Event History Area", 1, (155, 155, 155), (0, 0, 0))
    win.blit(img, (2, 132))
    ypos = 450
    h = list(history)
    h.reverse()
    for line in h:
        r = win.blit(line, (10, ypos))
        win.fill(0, (r.right, r.top, 620, r.height))
        ypos -= font.get_height()


def draw_usage_in_history(history, text):
    lines = text.split("\n")
    for line in lines:
        if line == "" or "===" in line:
            continue
        img = font.render(line, 1, (50, 200, 50), (0, 0, 0))
        history.append(img)


def main():
    """主函数 - 事件列表示例程序入口点"""
    pg.init()  # 初始化Pygame
    pygame._sdl2.controller.init()  # 初始化SDL2控制器系统

    print(usage)  # 打印使用说明到控制台

    # 创建可调整大小的窗口
    win = pg.display.set_mode((640, 480), pg.RESIZABLE)
    pg.display.set_caption("Mouse Focus Workout. h key for help")

    global font
    font = pg.font.Font(None, 26)  # 创建默认字体，26号大小

    # 初始化开关状态图像
    img_on_off.append(font.render("Off", 1, (0, 0, 0), (255, 50, 50)))  # 红色"关"状态
    img_on_off.append(font.render("On", 1, (0, 0, 0), (50, 255, 50)))  # 绿色"开"状态

    # 存储事件历史记录（文本表面列表）
    history = []

    # 初始化游戏手柄/控制器
    for x in range(pg.joystick.get_count()):  # 遍历所有连接的设备
        if pygame._sdl2.controller.is_controller(x):  # 检查是否为控制器
            c = pygame._sdl2.controller.Controller(x)  # 创建控制器对象
            txt = "Enabled controller: " + c.name  # 控制器名称
        else:  # 普通游戏手柄
            j = pg.joystick.Joystick(x)  # 创建游戏手柄对象
            txt = "Enabled joystick: " + j.get_name()  # 手柄名称

        img = font.render(txt, 1, (50, 200, 50), (0, 0, 0))  # 渲染设备信息
        history.append(img)  # 添加到历史记录

    # 如果没有连接任何设备
    if not pg.joystick.get_count():
        img = font.render("No Joysticks to Initialize", 1, (50, 200, 50), (0, 0, 0))
        history.append(img)  # 添加提示信息

    going = True  # 主循环标志
    while going:
        # 处理事件队列
        for e in pg.event.get():
            if e.type == pg.KEYDOWN:  # 按键事件
                if e.key == pg.K_ESCAPE:  # ESC键退出
                    going = False
                else:
                    global last_key
                    last_key = e.key  # 记录最后按下的键
                if e.key == pg.K_h:  # h键显示帮助
                    draw_usage_in_history(history, usage)
                if e.key == pg.K_c:  # c键切换控制器事件状态
                    current_state = pygame._sdl2.controller.get_eventstate()
                    pygame._sdl2.controller.set_eventstate(not current_state)

            if e.type == pg.MOUSEBUTTONDOWN and e.button == 1:  # 鼠标左键点击
                pg.event.set_grab(not pg.event.get_grab())  # 切换输入抓取状态

            if e.type == pg.MOUSEBUTTONDOWN and e.button == 3:  # 鼠标右键点击
                pg.mouse.set_visible(not pg.mouse.get_visible())  # 切换鼠标可见性

            if e.type != pg.MOUSEMOTION:  # 排除鼠标移动事件（太频繁）
                txt = f"{pg.event.event_name(e.type)}: {e.dict}"  # 格式化事件信息
                img = font.render(txt, 1, (50, 200, 50), (0, 0, 0))  # 渲染事件文本
                history.append(img)  # 添加到历史记录
                history = history[-13:]  # 保持最近13条记录

            if e.type == pg.VIDEORESIZE:  # 窗口大小调整事件
                win = pg.display.set_mode(e.size, pg.RESIZABLE)  # 重新设置窗口大小

            if e.type == pg.QUIT:  # 窗口关闭事件
                going = False

        # 绘制界面
        drawstatus(win)  # 绘制状态区域
        drawhistory(win, history)  # 绘制事件历史区域

        pg.display.flip()  # 更新整个显示
        pg.time.wait(10)  # 短暂延迟，控制CPU使用率

    pg.quit()  # 退出Pygame
    raise SystemExit  # 退出程序


if __name__ == "__main__":
    main()
main()
